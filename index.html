<!DOCTYPE html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PoliticalTinder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.4.0/dist/confetti.browser.min.js"></script>
    <style>
      .card {
        transition: transform 0.5s ease, opacity 0.5s ease;
        cursor: grab;
        user-select: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      .card.dragging {
        transition: none;
      }
      .swipe-left {
        transform: translateX(-100%) rotate(-30deg);
        opacity: 0;
      }
      .swipe-right {
        transform: translateX(100%) rotate(30deg);
        opacity: 0;
      }
      .swipe-down {
        transform: translateY(100%) rotate(0deg);
        opacity: 0;
      }
      .indicator {
        position: absolute;
        top: 10px;
        font-size: 2rem;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .indicator.left {
        left: 10px;
        color: red;
      }
      .indicator.right {
        right: 10px;
        color: green;
      }
      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .overlay.like {
        background: rgba(0, 255, 0, 0.3);
      }
      .overlay.dislike {
        background: rgba(255, 0, 0, 0.3);
      }
      .card-enter {
        animation: cardEnter 0.3s ease;
      }

      @keyframes cardEnter {
        0% {
          transform: translateY(20px) scale(0.95);
          opacity: 0;
        }
        100% {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
      }
    </style>
  </head>
  <body
    class="bg-gradient-to-br from-gray-100 to-gray-200 dark:bg-gradient-to-br dark:from-gray-800 dark:to-gray-900 min-h-screen flex flex-col items-center justify-center p-4"
  >
    <button
      id="theme-toggle"
      class="absolute top-4 right-4 p-2 bg-gray-200 dark:bg-gray-700 rounded-full"
    >
      üåì
    </button>

    <div id="card-container" class="relative w-full max-w-sm h-[70vh]">
      <!-- Cards -->
      <div class="indicator left">üëé</div>
      <div class="indicator right">üëç</div>
    </div>

    <div class="mt-8 flex space-x-4">
      <button
        id="dislike-btn"
        class="p-3 bg-red-500 text-white rounded-full shadow-lg hover:bg-red-600"
      >
        üëé
      </button>
      <button
        id="skip-btn"
        class="p-3 bg-yellow-500 text-white rounded-full shadow-lg hover:bg-yellow-600"
      >
        ‚è≠Ô∏è
      </button>
      <button
        id="like-btn"
        class="p-3 bg-green-500 text-white rounded-full shadow-lg hover:bg-green-600"
      >
        üëç
      </button>
    </div>

    <div id="score-container" class="mt-8 text-center hidden">
      <h2 class="text-xl font-bold dark:text-white">
        Your Political Alignment
      </h2>
      <p id="score" class="text-lg dark:text-gray-300"></p>
    </div>

    <div
      id="results-container"
      class="hidden w-full max-w-4xl mt-8 p-4 bg-white dark:bg-gray-800 rounded-lg shadow-lg"
    >
      <h2 class="text-xl font-bold dark:text-white mb-4">Your Votes</h2>
      <div class="grid grid-cols-2 gap-4">
        <div>
          <h3 class="text-lg font-bold dark:text-white mb-2">üëç Voted For</h3>
          <ul id="for-list" class="space-y-2"></ul>
        </div>
        <div>
          <h3 class="text-lg font-bold dark:text-white mb-2">üëé Voted Against</h3>
          <ul id="against-list" class="space-y-2"></ul>
        </div>
      </div>
    </div>

    <script>
      let allChoices = [];
      let currentChoices = [];
      let currentIndex = 0;
      let isAnimating = false;
      const cardContainer = document.getElementById("card-container");
      const leftIndicator = document.querySelector(".indicator.left");
      const rightIndicator = document.querySelector(".indicator.right");
      const scoreContainer = document.getElementById("score-container");
      const scoreElement = document.getElementById("score");
      const resultsContainer = document.getElementById("results-container");
      const forList = document.getElementById("for-list");
      const againstList = document.getElementById("against-list");

      let userVotes = [];
      let userPoliticalAlignment = 0;
      let lastAlignment = 0;
      let stableCount = 0;

      async function loadCards() {
        const response = await fetch("cards.json");
        allChoices = await response.json();
        startGame();
      }

      function startGame() {
        currentChoices = getRandomCards(10); // Start with 10 random cards
        renderCards();
      }

      function getRandomCards(count) {
        const shuffled = allChoices.sort(() => 0.5 - Math.random());
        return shuffled.slice(0, count);
      }

      function getAdaptedCards() {
        // Filter cards that are closer to the user's political alignment
        return allChoices
          .filter(
            (choice) =>
              Math.abs(choice.forPoliticalAlignment - userPoliticalAlignment) <
              0.5
          )
          .sort(
            (a, b) =>
              Math.abs(a.forPoliticalAlignment - userPoliticalAlignment) -
              Math.abs(b.forPoliticalAlignment - userPoliticalAlignment)
          )
          .slice(0, 10); // Return top 10 relevant cards
      }

      function createCard(choice) {
        const card = document.createElement("div");
        card.className =
          "card absolute w-full h-full bg-white dark:bg-gray-700 rounded-lg shadow-lg overflow-hidden flex flex-col";
        card.innerHTML = `
    <div class="p-3 flex-shrink-0">
      <h2 class="text-lg font-bold dark:text-white">${choice.title}</h2>
      <p class="text-sm text-gray-500 dark:text-gray-400 truncate">${choice.dateScrutin} ‚Ä¢ ${choice.totalVoters} voters</p>
    </div>
    <div class="p-3 overflow-y-auto flex-grow">
      <p class="text-sm text-gray-600 dark:text-gray-300">${choice.summary}</p>
    </div>
    <div class="overlay like"></div>
    <div class="overlay dislike"></div>
  `;
        return card;
      }

      function renderCards() {
        if (currentIndex >= currentChoices.length) {
          currentChoices = getAdaptedCards(); // Adapt cards based on user's alignment
          currentIndex = 0;
        }

        cardContainer.innerHTML = "";
        const cardsToShow = currentChoices.slice(
          currentIndex,
          currentIndex + 3
        );
        cardsToShow.forEach((choice, index) => {
          const card = createCard(choice);
          if (index === 0) {
            card.classList.add("card-enter");
          } else {
            card.style.transform = `translateY(${index * 20}px) scale(${
              1 - index * 0.05
            })`;
          }
          card.style.zIndex = cardsToShow.length - index;
          cardContainer.appendChild(card);
        });
        addDragListeners(cardContainer.querySelector(".card"));
      }

      function addDragListeners(card) {
        let isDragging = false;
        let startX, startY, offsetX, offsetY;

        card.addEventListener("mousedown", startDrag);
        card.addEventListener("touchstart", startDrag, { passive: true });

        function startDrag(e) {
          if (isAnimating) return;
          isDragging = true;
          card.classList.add("dragging");
          startX = e.clientX || e.touches[0].clientX;
          startY = e.clientY || e.touches[0].clientY;
          document.addEventListener("mousemove", drag);
          document.addEventListener("touchmove", drag, { passive: true });
          document.addEventListener("mouseup", endDrag);
          document.addEventListener("touchend", endDrag);
        }

        function drag(e) {
          if (!isDragging) return;
          offsetX = (e.clientX || e.touches[0].clientX) - startX;
          offsetY = (e.clientY || e.touches[0].clientY) - startY;
          const rotate = offsetX * 0.1;
          card.style.transform = `translate(${offsetX}px, ${offsetY}px) rotate(${rotate}deg)`;

          const opacity = Math.min(Math.abs(offsetX) / 100, 1);
          if (offsetX > 0) {
            rightIndicator.style.opacity = opacity;
            leftIndicator.style.opacity = 0;
            card.querySelector(".overlay.like").style.opacity = opacity;
            card.querySelector(".overlay.dislike").style.opacity = 0;
          } else {
            leftIndicator.style.opacity = opacity;
            rightIndicator.style.opacity = 0;
            card.querySelector(".overlay.dislike").style.opacity = opacity;
            card.querySelector(".overlay.like").style.opacity = 0;
          }
        }

        function endDrag() {
          if (!isDragging) return;
          isDragging = false;
          card.classList.remove("dragging");
          document.removeEventListener("mousemove", drag);
          document.removeEventListener("touchmove", drag);
          document.removeEventListener("mouseup", endDrag);
          document.removeEventListener("touchend", endDrag);

          const threshold = 100;
          if (Math.abs(offsetX) > threshold) {
            swipeCard(offsetX > 0 ? "right" : "left");
          } else {
            card.style.transition = "transform 0.3s ease";
            card.style.transform = "translate(0, 0) rotate(0deg)";
            setTimeout(() => {
              card.style.transition = "";
            }, 300);
          }

          leftIndicator.style.opacity = 0;
          rightIndicator.style.opacity = 0;
          card.querySelector(".overlay.like").style.opacity = 0;
          card.querySelector(".overlay.dislike").style.opacity = 0;
        }
      }

      function swipeCard(direction) {
        if (isAnimating) return;
        isAnimating = true;

        const card = cardContainer.querySelector(".card");
        if (!card) return;

        if (direction === "right") {
          card.querySelector(".overlay.like").style.opacity = 1;
          userVotes.push({ choice: currentChoices[currentIndex], vote: "for" });
        } else if (direction === "left") {
          card.querySelector(".overlay.dislike").style.opacity = 1;
          userVotes.push({
            choice: currentChoices[currentIndex],
            vote: "against",
          });
        }

        card.style.transition = "transform 0.5s ease, opacity 0.5s ease";
        if (direction === "right") {
          card.style.transform = "translateX(100%) rotate(30deg)";
        } else if (direction === "left") {
          card.style.transform = "translateX(-100%) rotate(-30deg)";
        } else if (direction === "down") {
          card.style.transform = "translateY(100%) rotate(0deg)";
        }
        card.style.opacity = 0;

        setTimeout(() => {
          currentIndex++;
          calculatePoliticalAlignment();
          if (stableCount >= 3) {
            endGame();
          } else {
            renderCards();
          }
          isAnimating = false;
        }, 700); // (500 -> animation + 200 -> delay)
      }

      function calculatePoliticalAlignment() {
        let totalAlignment = 0;
        userVotes.forEach((vote) => {
          if (vote.vote === "for") {
            totalAlignment += vote.choice.forPoliticalAlignment;
          } else {
            totalAlignment += vote.choice.againstPoliticalAlignment;
          }
        });
        userPoliticalAlignment = totalAlignment / userVotes.length;

        // Check if the alignment has stabilized
        if (Math.abs(userPoliticalAlignment - lastAlignment) < 0.01) {
          stableCount++;
        } else {
          stableCount = 0;
        }
        lastAlignment = userPoliticalAlignment;

        scoreElement.textContent = userPoliticalAlignment.toFixed(2);
        scoreContainer.classList.remove("hidden");
      }

      function endGame() {
        // Hide the card container and buttons
        cardContainer.classList.add("hidden");
        document.querySelector(".mt-8.flex.space-x-4").classList.add("hidden");

        // Show the score and results container
        scoreContainer.classList.remove("hidden");
        resultsContainer.classList.remove("hidden");

        // Clear previous results
        forList.innerHTML = "";
        againstList.innerHTML = "";

        // Populate the "For" and "Against" lists
        userVotes.forEach((vote) => {
          const listItem = document.createElement("li");
          listItem.className = "flex items-center justify-between text-sm dark:text-gray-300";

          const title = document.createElement("span");
          title.textContent = vote.choice.title;

          const scoreTag = document.createElement("span");
          scoreTag.className = `px-2 py-1 rounded-full text-xs font-bold ${
            vote.vote === "for" ? "bg-blue-500" : "bg-red-500"
          } text-white`;
          scoreTag.textContent = vote.vote === "for"
            ? vote.choice.forPoliticalAlignment.toFixed(2)
            : vote.choice.againstPoliticalAlignment.toFixed(2);

          listItem.appendChild(title);
          listItem.appendChild(scoreTag);

          if (vote.vote === "for") {
            forList.appendChild(listItem);
          } else {
            againstList.appendChild(listItem);
          }
        });

        // Trigger confetti effect
        triggerConfetti();
      }

      function triggerConfetti() {
        confetti({
          particleCount: 100,
          spread: 70,
          origin: { y: 0.6 },
        });
      }

      document
        .getElementById("like-btn")
        .addEventListener("click", () => swipeCard("right"));
      document
        .getElementById("dislike-btn")
        .addEventListener("click", () => swipeCard("left"));
      document
        .getElementById("skip-btn")
        .addEventListener("click", () => swipeCard("down"));

      document.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft") {
          swipeCard("left");
        } else if (e.key === "ArrowRight") {
          swipeCard("right");
        } else if (e.key === "ArrowDown") {
          swipeCard("down");
        }
      });

      const themeToggle = document.getElementById("theme-toggle");
      themeToggle.addEventListener("click", () => {
        const htmlElement = document.documentElement;
        htmlElement.classList.toggle("dark");
        const isDarkMode = htmlElement.classList.contains("dark");
        themeToggle.textContent = isDarkMode ? "üåû" : "üåì";
      });

      loadCards();
    </script>
    <script>
      tailwind.config = {
        darkMode: "class",
        theme: {
          extend: {
            colors: {
              dark: {
                bg: "#1a1a1a",
                surface: "#2d2d2d",
                border: "#404040",
              },
            },
          },
        },
      };
    </script>
  </body>
</html>